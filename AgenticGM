from typing import TypedDict, List, Dict, Annotated
from pathlib import Path
from operator import add
from langgraph.graph import StateGraph, END
from langchain_core.messages import HumanMessage
from langchain_core.prompts import ChatPromptTemplate
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings.fake import FakeEmbeddings
from langchain_community.vectorstores import FAISS

# === PLACEHOLDER CONFIG ===
LLM_MODEL = "XXX"  # e.g., gpt-4, llama3, mistral
# RAG_VECTOR_DB = "XXX"  # e.g., faiss, chroma, milvus
LORE_FILE = Path("LORE.txt")
_TEXT_SPLITTER = RecursiveCharacterTextSplitter(chunk_size=500, chunk_overlap=50)

# === State Definition ===
class GameState(TypedDict):
    user_message: str
    query: str
    next: str
    inventory: Dict[str, int]
    lore: str
    history: Annotated[List[str], add]  # Will append, not replace
    dice_roll: int
    story: str
    output: str

# === Define Tools ===
class RandomizerTool:
    def roll(self, sides=20):
        import random
        return random.randint(1, sides)

randomizer = RandomizerTool()

# === Define Agents as Functions ===

def orchestrator(state: GameState):
    """Decides which agent to call next based on state."""
    return {"next": "historian"}

def quartermaster(state: GameState):
    """Manages inventory and state."""
    inventory = state.get("inventory", {})
    inventory["gold"] = inventory.get("gold", 0) + 10
    return {"inventory": inventory}

def historian(state: GameState):
    """Fetches lore using an ephemeral embedding built from LORE.txt."""
    query = state.get("query", "").strip()
    # Legacy vector DB flow retained for reference (commented out per request):
    # lore = f"[RAG:{RAG_VECTOR_DB}] Retrieved lore for query: {query}"
    # return {"lore": lore}

    if not LORE_FILE.exists():
        return {"lore": "Lore source file (LORE.txt) is missing."}

    raw_lore = LORE_FILE.read_text(encoding="utf-8").strip()
    if not raw_lore:
        return {"lore": "Lore source file (LORE.txt) is empty."}

    lore_chunks = [chunk.strip() for chunk in _TEXT_SPLITTER.split_text(raw_lore) if chunk.strip()]
    if not lore_chunks:
        return {"lore": "Unable to process lore from LORE.txt."}

    embeddings = FakeEmbeddings(size=1536)
    # lore = f"[RAG:{RAG_VECTOR_DB}] Retrieved lore for query: {query}"
    vector_store = FAISS.from_texts(lore_chunks, embeddings)

    if not query:
        selected_chunks = lore_chunks[:1]
    else:
        results = vector_store.similarity_search(query, k=min(3, len(lore_chunks)))
        selected_chunks = [doc.page_content for doc in results] or lore_chunks[:1]

    combined_lore = "\n\n".join(selected_chunks)
    return {"lore": combined_lore}

def journal(state: GameState):
    """Tracks prior conversation."""
    message = state.get("user_message", "")
    return {"history": [message]}

def gambler(state: GameState):
    """Controls random outcomes."""
    roll = randomizer.roll(20)
    return {"dice_roll": roll}

def storyteller(state: GameState):
    """Generates narrative text from inputs."""
    lore = state.get("lore", "")
    roll = state.get("dice_roll", 0)
    prompt = ChatPromptTemplate.from_messages([
        ("system", "You are a fantasy storyteller."),
        ("user", f"Lore: {lore}\nDice Roll: {roll}\nWrite the next story segment.")
    ])
    story_text = f"[LLM:{LLM_MODEL}] Generated story with roll {roll} and lore."
    return {"story": story_text}

def gm(state: GameState):
    """Final assembly of outputs."""
    return {
        "output": f"GM Narration:\n{state.get('story', '')}\nInventory: {state.get('inventory', {})}"
    }

# === Build LangGraph ===
graph = StateGraph(GameState)

# Register agent nodes
graph.add_node("orchestrator", orchestrator)
graph.add_node("quartermaster", quartermaster)
graph.add_node("historian", historian)
graph.add_node("journal", journal)
graph.add_node("gambler", gambler)
graph.add_node("storyteller", storyteller)
graph.add_node("gm", gm)

# Define edges (simple linear flow for now)
graph.add_edge("orchestrator", "quartermaster")
graph.add_edge("quartermaster", "historian")
graph.add_edge("historian", "journal")
graph.add_edge("journal", "gambler")
graph.add_edge("gambler", "storyteller")
graph.add_edge("storyteller", "gm")
graph.add_edge("gm", END)

# Set entry point
graph.set_entry_point("orchestrator")

# === Compile Graph ===
app = graph.compile()

# === Example Run ===
initial_state: GameState = {
    "user_message": "The party explores the ancient ruins.",
    "query": "ancient ruins",
    "next": "",
    "inventory": {},
    "lore": "",
    "history": [],
    "dice_roll": 0,
    "story": "",
    "output": ""
}

final_state = app.run(initial_state)
print(final_state["output"])
